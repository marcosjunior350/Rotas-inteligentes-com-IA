# -*- coding: utf-8 -*-
"""Rota inteligente com IA

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/10qVp5lhjcV1qNo-MxFMU4_s82Ygg0wWI
"""

# Biblitecas do projeto

import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
import networkx as nx
from sklearn.cluster import KMeans

# Parte 1 - Carregando os arquivos CSV

try:
    entregas_df = pd.read_csv('entregas.csv')
    mapa_df = pd.read_csv('mapa_grafo.csv')

    # Separar restaurante dos pontos de entrega para uso posterior
    restaurante = entregas_df[entregas_df['id'] == 'restaurante']
    pedidos = entregas_df[entregas_df['id'] != 'restaurante']

    print("--- Arquivos CSV carregados com sucesso! ---")
    print("Amostra dos dados de entrega:")
    print(pedidos.head())
    print("\n")

except FileNotFoundError:
    print("ERRO: Certifique-se de que os arquivos 'entregas.csv' e 'mapa_grafo.csv' foram carregados no Colab.")
    print("Clique no ícone de pasta na barra lateral esquerda para fazer o upload.")

# Parte 2 - Clustering com KMeans

def agrupar_entregas(pedidos_df, n_entregadores):
    """Agrupa os pedidos em clusters usando K-Means."""
    kmeans = KMeans(n_clusters=n_entregadores, random_state=42, n_init=10)

    # Seleciona apenas as coordenadas para o clustering
    coordenadas = pedidos_df[['ponto_x', 'ponto_y']]
    pedidos_df['cluster'] = kmeans.fit_predict(coordenadas)
    return pedidos_df

def plotar_clusters(pedidos_clusterizados, restaurante_df):
    """Gera um gráfico visualizando os clusters de entrega."""
    plt.figure(figsize=(10, 8))

    # 'hue' colore os pontos com base na coluna 'cluster'
    plt.scatter(pedidos_clusterizados['ponto_x'], pedidos_clusterizados['ponto_y'], c=pedidos_clusterizados['cluster'], cmap='viridis', s=100, label='Pedidos')
    plt.scatter(restaurante_df['ponto_x'], restaurante_df['ponto_y'], c='red', marker='*', s=300, label='Restaurante')
    plt.title('Agrupamento de Entregas por Entregador (Clusters)')
    plt.xlabel('Coordenada X')
    plt.ylabel('Coordenada Y')
    plt.legend()
    plt.grid(True)
    plt.show()

# Parte 3 - Criação do Grafo, Roteirização e Visualização do Mapa

def criar_grafo(mapa_df):
    """Cria um grafo a partir do DataFrame do mapa."""
    G = nx.Graph()
    for _, row in mapa_df.iterrows():
        G.add_edge(row['origem'], row['destino'], weight=row['peso'])
    return G

def otimizar_rota_cluster(grafo, restaurante_id, pontos_do_cluster):
    """Encontra a rota otimizada para um único cluster (heurística do vizinho mais próximo com A*)."""
    if not pontos_do_cluster:
        return [], 0

    rota_final = [restaurante_id]
    custo_total = 0
    pontos_nao_visitados = pontos_do_cluster.copy()
    ponto_atual = restaurante_id

    while pontos_nao_visitados:
        menor_distancia = float('inf')
        proximo_ponto = None

        for ponto in pontos_nao_visitados:
            try:
                # Usa A* para achar o caminho mais curto do ponto atual para o próximo
                distancia = nx.astar_path_length(grafo, ponto_atual, ponto, weight='weight')
                if distancia < menor_distancia:
                    menor_distancia = distancia
                    proximo_ponto = ponto
            except nx.NetworkXNoPath:
                # Ignora se não houver caminho
                continue

        if proximo_ponto is None:
            print(f"Alerta: Não foi possível encontrar caminho para os pontos restantes de {ponto_atual}")
            break

        custo_total += menor_distancia
        ponto_atual = proximo_ponto
        rota_final.append(ponto_atual)
        pontos_nao_visitados.remove(ponto_atual)

    # Adiciona o caminho de volta ao restaurante
    try:
        custo_retorno = nx.astar_path_length(grafo, ponto_atual, restaurante_id, weight='weight')
        custo_total += custo_retorno
        rota_final.append(restaurante_id)
    except nx.NetworkXNoPath:
        print(f"Alerta: Não foi possível encontrar caminho de volta para {restaurante_id}")

    return rota_final, custo_total

def desenhar_mapa_grafo(mapa_df, nome_arquivo='mapa_grafo.png'):
    """Desenha o grafo do mapa e salva como imagem."""
    G = criar_grafo(mapa_df)
    plt.figure(figsize=(12, 10))
    # Define uma posição para os nós para que o layout fique consistente
    pos = nx.spring_layout(G, seed=42)
    nx.draw(G, pos, with_labels=True, node_size=2000, node_color='skyblue', font_size=10, font_weight='bold')
    # Adiciona os pesos (distâncias) nas arestas
    labels = nx.get_edge_attributes(G, 'weight')
    nx.draw_networkx_edge_labels(G, pos, edge_labels=labels)
    plt.title('Diagrama do Grafo do Mapa')
    # Salva a imagem no diretório do Colab
    plt.savefig(nome_arquivo)
    plt.show()
    print(f"Diagrama do grafo salvo em: {nome_arquivo}")

# Parte 4 - Script Principal

if __name__ == "__main__":

    # Entregadores disponíveis / Peso de cada ponto no Grafo
    NUMERO_DE_ENTREGADORES = 2
    ESCALA_METROS = 100

    # Agrupar os pedidos
    pedidos_clusterizados = agrupar_entregas(pedidos.copy(), NUMERO_DE_ENTREGADORES)
    print("--- Pedidos Agrupados por Cluster ---")
    print(pedidos_clusterizados)
    print("\n")

    # Visualizar os clusters
    plotar_clusters(pedidos_clusterizados, restaurante)

    # Criar o grafo da cidade
    grafo_mapa = criar_grafo(mapa_df)
    desenhar_mapa_grafo(mapa_df)

    # Otimizar a rota para cada cluster/entregador
    print("--- Rotas Otimizadas ---")
    for i in range(NUMERO_DE_ENTREGADORES):
        print(f"\n>> Rota para o Entregador {i+1} (Cluster {i}):")

        # Pega os IDs dos pedidos para o cluster atual
        pontos_do_cluster = pedidos_clusterizados[pedidos_clusterizados['cluster'] == i]['id'].tolist()

        if not pontos_do_cluster:
            print("Nenhum pedido para este entregador.")
            continue

        rota, custo_abstrato = otimizar_rota_cluster(grafo_mapa, "restaurante", pontos_do_cluster)

        # Aplica a escala para converter o custo em Km
        distancia_km = (custo_abstrato * ESCALA_METROS) / 1000

        print(f"  - Rota Otimizada: {' -> '.join(rota)}")
        print(f"  - Distância Total: {distancia_km:.2f} km")

"""# Nova seção"""